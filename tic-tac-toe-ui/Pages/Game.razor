@page "/game"
@layout MinimalLayout
@using Microsoft.AspNetCore.SignalR.Client
@using System.Timers
@using System.Globalization
@using System.Net.Http.Json
@using tic_tac_toe_ui.Models
@using tic_tac_toe_ui.Layout
@using MudBlazor
@inject IJSRuntime JSRuntime
@inject HttpClient Http
@inject NavigationManager Navigation

<MudContainer Class="py-8">
    <MudCard Elevation="4" Class="pa-6" Style="background: rgba(255, 255, 255, 0.95); border-radius: 16px;">
        <MudCardContent>
            <MudText Typo="Typo.h5" Align="Align.Center" Color="Color.Primary" Class="mb-6">
                Крестики-нолики с задачами
            </MudText>

            @if (!isAuthenticated)
            {
                <MudText Align="Align.Center" Class="mb-4">
                    Вы не авторизованы.
                </MudText>
                <MudGrid Justify="Justify.Center">
                    <MudItem>
                        <MudButton Href="/login" Variant="Variant.Filled" Color="Color.Primary" Class="mx-2" StartIcon="@Icons.Material.Filled.Login">
                            Войти
                        </MudButton>
                    </MudItem>
                    <MudItem>
                        <MudButton Href="/register" Variant="Variant.Outlined" Color="Color.Secondary" Class="mx-2" StartIcon="@Icons.Material.Filled.AppRegistration">
                            Зарегистрироваться
                        </MudButton>
                    </MudItem>
                </MudGrid>
            }
            else
            {
                <MudGrid Justify="Justify.SpaceBetween" Class="mb-4">
                    <MudItem>
                        <MudText>Вы вошли как: <strong>@currentUsername</strong></MudText>
                    </MudItem>
                    <MudItem>
                        <MudButton OnClick="Logout" Variant="Variant.Text" Color="Color.Error" StartIcon="@Icons.Material.Filled.ExitToApp">
                            Выйти
                        </MudButton>
                    </MudItem>
                </MudGrid>

                @if (!connected)
                {
                    <MudText Class="mb-4">Выберите параметры игры:</MudText>
                    <MudGrid>
                        <MudItem xs="12" sm="6">
                            <MudSelect T="string" Label="Сложность" @bind-Value="difficulty" Variant="Variant.Outlined" Dense="true">
                                <MudSelectItem Value="@("easy")">Лёгкий</MudSelectItem>
                                <MudSelectItem Value="@("medium")">Средний</MudSelectItem>
                                <MudSelectItem Value="@("hard")">Сложный</MudSelectItem>
                            </MudSelect>
                        </MudItem>
                        <MudItem xs="12" sm="6">
                            <MudSelect T="int" Label="Размер поля" @bind-Value="lineLength" Variant="Variant.Outlined" Dense="true">
                                <MudSelectItem Value="3">3x3</MudSelectItem>
                                <MudSelectItem Value="4">4x4</MudSelectItem>
                                <MudSelectItem Value="5">5x5</MudSelectItem>
                            </MudSelect>
                        </MudItem>
                        <MudItem xs="12" Class="mt-4">
                            <MudButton OnClick="Connect" Disabled="isConnecting" Variant="Variant.Filled" Color="Color.Primary" FullWidth="true" StartIcon="@Icons.Material.Filled.PlayArrow">
                                Присоединиться
                            </MudButton>
                            @if (isConnecting)
                            {
                                <MudProgressCircular Color="Color.Primary" Size="Size.Small" Indeterminate="true" Class="mt-2" />
                            }
                        </MudItem>
                    </MudGrid>
                }
                else if (isWaiting)
                {
                    <MudText Align="Align.Center" Class="mb-4">
                        Ожидание второго игрока...
                    </MudText>
                    <MudProgressLinear Color="Color.Secondary" Indeterminate="true" />
                }

                else if (gameOverMessage != null)
                {
                    <MudText Align="Align.Center" Color="Color.Success" Class="mb-4">
                        @gameOverMessage
                    </MudText>

                    @if (board != null && board.Length == boardSize && board.All(row => row != null && row.Length == boardSize))
                    {
                        int cellSize = 60;
                        int boardWidth = boardSize * cellSize + (boardSize - 1) * 6; // Точное вычисление с gap
                        int boardHeight = boardSize * cellSize + (boardSize - 1) * 6;

                        string CenterCoord(int index) =>
                        (index * (cellSize + 6) + cellSize / 2.0).ToString("F1", CultureInfo.InvariantCulture); // Центр клетки

                        <div style="position: relative; width: @(boardWidth)px; height: @(boardHeight)px; margin: 0 auto; overflow: hidden;">
                            <div class="board-grid"
                                 style="display: grid; grid-template-columns: repeat(@boardSize, 60px); gap: 6px; position: relative;">
                                @for (int i = 0; i < boardSize; i++)
                                {
                                    for (int j = 0; j < boardSize; j++)
                                    {
                                        if (i < board.Length && board[i] != null && j < board[i].Length)
                                        {
                                            char symbol = board[i][j];
                                            <MudButton Variant="Variant.Filled"
                                                       Color="Color.Default"
                                                       Disabled="true"
                                                       Style="@($"width: {cellSize}px; height: {cellSize}px; font-size: 24px; font-weight: bold;")"
                                                       Class="d-flex align-center justify-center">
                                                @(symbol == '\0' ? "" : symbol.ToString())
                                            </MudButton>
                                        }
                                        else
                                        {
                                            <MudButton Variant="Variant.Filled"
                                                       Color="Color.Error"
                                                       Disabled="true"
                                                       Style="@($"width: {cellSize}px; height: {cellSize}px; font-size: 24px; font-weight: bold;")"
                                                       Class="d-flex align-center justify-center">
                                                ?
                                            </MudButton>
                                        }
                                    }
                                }
                            </div>
                            @if (winLineType != null
                           && startX >= 0 && startX < boardSize
                           && endX >= 0 && endX < boardSize
                           && startY >= 0 && startY < boardSize
                           && endY >= 0 && endY < boardSize
                           && (startX != endX || startY != endY))
                            {
                                <svg style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1;">
                                    <line x1="@CenterCoord(startY)"
                                          y1="@CenterCoord(startX)"
                                          x2="@CenterCoord(endY)"
                                          y2="@CenterCoord(endX)"
                                          stroke="#ef4444"
                                          stroke-width="6"
                                          stroke-linecap="round" />
                                </svg>
                            }
                        </div>
                    }
                    else
                    {
                        @if (board == null)
                        {
                            <MudText Color="Color.Error">board is null</MudText>
                        }
                        else if (board.Length != boardSize)
                        {
                            <MudText Color="Color.Error">board.Length != boardSize (@board.Length != @boardSize)</MudText>
                        }
                        else if (!board.All(row => row != null && row.Length == boardSize))
                        {
                            <MudText Color="Color.Error">Некоторые строки null или неправильной длины</MudText>
                        }
                        else
                        {
                            <MudText Color="Color.Error">Ошибка: игровое поле не готово или повреждено</MudText>
                        }
                    }

                    <MudGrid Justify="Justify.Center" Class="mt-4">
                        <MudItem>
                            <MudButton OnClick="ResetGame"
                                       Variant="Variant.Filled"
                                       Color="Color.Primary"
                                       Class="mx-2"
                                       StartIcon="@Icons.Material.Filled.Refresh">
                                Реванш
                            </MudButton>
                        </MudItem>
                        <MudItem>
                            <MudButton OnClick="ReturnToMainMenu"
                                       Variant="Variant.Outlined"
                                       Color="Color.Secondary"
                                       Class="mx-2"
                                       StartIcon="@Icons.Material.Filled.Home">
                                Вернуться в главное меню
                            </MudButton>
                        </MudItem>
                    </MudGrid>
                }
                //старое
                else
                {
                    <MudText Class="mb-2">Вы играете за: <strong>@playerSymbol</strong></MudText>
                    <MudText Class="mb-2">Ход игрока: <strong>@currentPlayer</strong> (Осталось: @timerSeconds с)</MudText>
                    <MudText Class="mb-4">Осталось до конца сессии: @((sessionTimerSeconds / 60)) мин @((sessionTimerSeconds % 60)) с</MudText>

                    @if (!string.IsNullOrEmpty(feedback))
                    {
                        <MudAlert Severity="@(feedback.Contains("Правильно") ? MudBlazor.Severity.Success : MudBlazor.Severity.Error)" Class="mb-4">
                            @feedback
                        </MudAlert>
                    }

                    @if (!string.IsNullOrEmpty(errorMessage))
                    {
                        <MudAlert Severity="MudBlazor.Severity.Error" Class="mb-4">
                            @errorMessage
                        </MudAlert>
                    }

                    @if (!string.IsNullOrEmpty(task) && selectedRow >= 0 && selectedCol >= 0 && board != null && selectedRow < board.Length && board[selectedRow] != null && selectedCol < board[selectedRow].Length && currentPlayer == currentUsername)
                    {
                        <MudPaper Elevation="2" Class="pa-4 mb-4">
                            <MudText Class="mb-2">Задача: @task</MudText>
                            <MudTextField @bind-Value="answer" Label="Введите ответ" Variant="Variant.Outlined" Class="mb-2" />
                            <MudButton OnClick="SubmitAnswer" Variant="Variant.Filled" Color="Color.Primary" StartIcon="@Icons.Material.Filled.Send">
                                Отправить
                            </MudButton>
                        </MudPaper>
                    }

                    <div style="position: relative; margin: 0 auto;">
                        @if (board != null && board.Length > 0 && board.All(row => row != null && row.Length == board.Length))
                        {
                            <div class="board-grid" style="display: grid; grid-template-columns: repeat(@boardSize, 1fr); gap: 6px; max-width: fit-content; margin: 0 auto;">
                                @for (int i = 0; i < boardSize; i++)
                                {
                                    for (int j = 0; j < boardSize; j++)
                                    {
                                        var rowIndex = i;
                                        var colIndex = j;
                                        <MudButton Variant="Variant.Filled" Color="Color.Default"
                                                   Disabled="@(currentPlayer != currentUsername || board[rowIndex][colIndex] != '\0' || gameOverMessage != null || (!string.IsNullOrEmpty(task) && (selectedRow >= 0 || selectedCol >= 0)))"
                                                   OnClick="() => MakeMove(rowIndex, colIndex)"
                                                   Style="width: 60px; height: 60px; font-size: 24px; font-weight: bold;"
                                                   Class="d-flex align-center justify-center mud-hover">
                                            @(board[rowIndex][colIndex] == '\0' ? "" : board[rowIndex][colIndex].ToString())
                                        </MudButton>
                                    }
                                }
                            </div>
                        }
                        else
                        {
                            <MudText Color="Color.Error">Ошибка: игровое поле не инициализировано или имеет некорректный размер</MudText>
                        }
                    </div>
                }

                @if (!string.IsNullOrEmpty(errorMessage))
                {
                    <MudAlert Severity="MudBlazor.Severity.Error" Class="mt-4">
                        @errorMessage
                    </MudAlert>
                }
            }
        </MudCardContent>
    </MudCard>
</MudContainer>

@code {
    private HubConnection? hubConnection;
    private string currentUsername = "";
    private int currentUserId;
    private string accessToken = "";
    private string refreshToken = "";
    private bool isAuthenticated = false;
    private string difficulty = "easy";
    private int lineLength = 3;
    private bool connected = false;
    private bool isWaiting = false;
    private bool isConnecting = false;
    private string? playerSymbol;
    private string? currentPlayer;
    private string? gameId;
    private string? player1;
    private string? player2;
    private char[][] board = new char[0][];
    private string? gameOverMessage;
    private string errorMessage = "";
    private int boardSize;
    private Timer? timer;
    private int timerSeconds = 8;
    private Timer? sessionTimer;
    private int sessionTimerSeconds = 15 * 60;
    private string task = "";
    private string answer = "";
    private int selectedRow = -1;
    private int selectedCol = -1;
    private string feedback = "";
    private bool isTaskPhase = false;
    private string? winLineType;
    private int startX, startY, endX, endY;
    private int maxRetryAttempts = 3;
    private int retryCount = 0;


    protected override async Task OnInitializedAsync()
    {
        await CheckAuth();
    }

    private async Task CheckAuth()
    {
        accessToken = await JSRuntime.InvokeAsync<string>("localStorage.getItem", "accessToken") ?? "";
        refreshToken = await JSRuntime.InvokeAsync<string>("localStorage.getItem", "refreshToken") ?? "";
        Console.WriteLine($"CheckAuth: AccessToken={accessToken}, RefreshToken={refreshToken}");

        if (string.IsNullOrEmpty(accessToken))
        {
            Console.WriteLine("CheckAuth: No access token found, redirecting to login");
            isAuthenticated = false;
            Navigation.NavigateTo("/login");
            return;
        }

        try
        {
            var response = await Http.PostAsJsonAsync("api/auth/validate", accessToken);
            Console.WriteLine($"CheckAuth: Validate response status={response.StatusCode}");
            if (response.IsSuccessStatusCode)
            {
                var result = await response.Content.ReadFromJsonAsync<ValidateTokenResponse>();
                currentUserId = result.UserId;
                currentUsername = result.Username;
                isAuthenticated = true;
                Console.WriteLine($"CheckAuth: Successfully validated, Username={currentUsername}");
            }
            else if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
            {
                errorMessage = "Ошибка на сервере при валидации токена. Проверьте API-сервер.";
                Console.WriteLine("CheckAuth: Server error during validation (500)");
                isAuthenticated = false;
                await Logout();
                return;
            }
            else
            {
                Console.WriteLine("CheckAuth: Token validation failed, attempting to refresh");
                await RefreshToken();
            }
        }
        catch (Exception ex)
        {
            errorMessage = $"Ошибка подключения к серверу: {ex.Message}. Проверьте, запущен ли API-сервер.";
            Console.WriteLine($"CheckAuth: Failed to validate token: {ex.Message}");
            isAuthenticated = false;
            await Logout();
            return;
        }

        StateHasChanged();
    }

    private async Task RefreshToken()
    {
        if (string.IsNullOrEmpty(refreshToken))
        {
            Console.WriteLine("RefreshToken: No refresh token available, logging out");
            await Logout();
            return;
        }

        try
        {
            var response = await Http.PostAsJsonAsync("api/auth/refresh", new RefreshTokenRequest
                {
                    AccessToken = accessToken,
                    RefreshToken = refreshToken
                });

            Console.WriteLine($"RefreshToken: Refresh response status={response.StatusCode}");
            if (response.IsSuccessStatusCode)
            {
                var result = await response.Content.ReadFromJsonAsync<RefreshTokenResponse>();
                accessToken = result.AccessToken;
                refreshToken = result.RefreshToken;
                await JSRuntime.InvokeVoidAsync("localStorage.setItem", "accessToken", accessToken);
                await JSRuntime.InvokeVoidAsync("localStorage.setItem", "refreshToken", refreshToken);
                Console.WriteLine($"RefreshToken: Successfully refreshed tokens, AccessToken={accessToken}");

                var validateResponse = await Http.PostAsJsonAsync("api/auth/validate", accessToken);
                Console.WriteLine($"RefreshToken: Validate after refresh status={validateResponse.StatusCode}");
                if (validateResponse.IsSuccessStatusCode)
                {
                    var validateResult = await validateResponse.Content.ReadFromJsonAsync<ValidateTokenResponse>();
                    currentUserId = validateResult.UserId;
                    currentUsername = validateResult.Username;
                    isAuthenticated = true;
                    Console.WriteLine($"RefreshToken: Successfully validated after refresh, Username={currentUsername}");
                    retryCount = 0;
                }
                else if (validateResponse.StatusCode == System.Net.HttpStatusCode.InternalServerError)
                {
                    errorMessage = "Ошибка на сервере при валидации нового токена. Проверьте API-сервер.";
                    Console.WriteLine("RefreshToken: Server error during validation after refresh (500)");
                    await Logout();
                    return;
                }
                else
                {
                    Console.WriteLine("RefreshToken: Validation after refresh failed, logging out");
                    await Logout();
                    return;
                }
            }
            else if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
            {
                errorMessage = "Ошибка на сервере при обновлении токена. Проверьте API-сервер.";
                Console.WriteLine("RefreshToken: Server error during refresh (500)");
                await Logout();
                return;
            }
            else
            {
                Console.WriteLine("RefreshToken: Refresh failed, logging out");
                await Logout();
                return;
            }
        }
        catch (Exception ex)
        {
            errorMessage = $"Не удалось обновить токен: {ex.Message}. Проверьте, запущен ли сервер.";
            Console.WriteLine($"RefreshToken: Failed: {ex.Message}");
            await Logout();
            return;
        }

        StateHasChanged();
    }

    private async Task Logout()
    {
        try
        {
            if (!string.IsNullOrEmpty(accessToken))
            {
                var response = await Http.PostAsync("api/auth/logout", null);
                Console.WriteLine($"Logout: Logout response status={response.StatusCode}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Logout: Failed: {ex.Message}");
            errorMessage = $"Не удалось выйти из системы: {ex.Message}. Проверьте, запущен ли сервер.";
        }
        finally
        {
            accessToken = "";
            refreshToken = "";
            currentUsername = "";
            currentUserId = 0;
            isAuthenticated = false;
            await JSRuntime.InvokeVoidAsync("localStorage.removeItem", "accessToken");
            await JSRuntime.InvokeVoidAsync("localStorage.removeItem", "refreshToken");

            if (hubConnection != null)
            {
                StopTimer();
                StopSessionTimer();
                await hubConnection.StopAsync();
                hubConnection = null;
            }
            connected = false;
            isWaiting = false;
            isConnecting = false;
            gameId = null;
            playerSymbol = null;
            currentPlayer = null;
            player1 = null;
            player2 = null;
            board = new char[0][];
            gameOverMessage = null;
            winLineType = null;
            errorMessage = "";
            task = "";
            feedback = "";
            selectedRow = -1;
            selectedCol = -1;
            isTaskPhase = false;
            sessionTimerSeconds = 15 * 60;
            retryCount = 0;
            Navigation.NavigateTo("/login");
            Console.WriteLine("Logout: Logged out, redirecting to login");
            StateHasChanged();
        }
    }

    private async Task Connect()
    {
        if (isConnecting)
        {
            Console.WriteLine("Connect: Already connecting, ignoring additional click");
            return;
        }

        if (string.IsNullOrEmpty(currentUsername))
        {
            errorMessage = "Необходимо войти в систему";
            Navigation.NavigateTo("/login");
            Console.WriteLine("Connect: No username, redirecting to login");
            return;
        }

        isConnecting = true;
        StateHasChanged();

        try
        {
            var validateResponse = await Http.PostAsJsonAsync("api/auth/validate", accessToken);
            Console.WriteLine($"Connect: Pre-connection validate response status={validateResponse.StatusCode}");
            if (!validateResponse.IsSuccessStatusCode)
            {
                if (validateResponse.StatusCode == System.Net.HttpStatusCode.InternalServerError)
                {
                    errorMessage = "Ошибка на сервере при валидации токена перед подключением. Проверьте API-сервер.";
                    Console.WriteLine("Connect: Server error during validation (500)");
                    await Logout();
                    return;
                }
                Console.WriteLine("Connect: Token invalid before connection, attempting to refresh");
                await RefreshToken();
                if (!isAuthenticated)
                {
                    Console.WriteLine("Connect: Refresh failed, user not authenticated, redirecting to login");
                    return;
                }
            }
        }
        catch (Exception ex)
        {
            errorMessage = $"Ошибка подключения к серверу: {ex.Message}. Проверьте, запущен ли API-сервер.";
            Console.WriteLine($"Connect: Failed to validate token: {ex.Message}");
            await Logout();
            return;
        }

        try
        {
            if (hubConnection != null)
            {
                await hubConnection.StopAsync();
                hubConnection = null;
            }

            hubConnection = new HubConnectionBuilder()
                .WithUrl("https://26.171.188.146:5001/gameHub", options =>
                {
                    options.Headers["Authorization"] = $"Bearer {accessToken}";
                })
                .WithAutomaticReconnect()
                .Build();

            hubConnection.On("WaitingForOpponent", () =>
            {
                Console.WriteLine("Received WaitingForOpponent");
                isWaiting = true;
                errorMessage = "";
                StateHasChanged();
            });

            hubConnection.On<string, string, string, Dictionary<string, char>>("GameStarted", (id, p1, p2, symbolMap) =>
    {
        Console.WriteLine($"Received GameStarted: {id}, {p1}, {p2}");
        isWaiting = false;
        gameId = id;
        player1 = p1;
        player2 = p2;
        playerSymbol = symbolMap[currentUsername].ToString();
        currentPlayer = p1;
        boardSize = lineLength;
        board = CreateEmptyBoard(boardSize);
        StartTimer();
        StartSessionTimer();
        gameOverMessage = null;
        winLineType = null;
        errorMessage = "";
        retryCount = 0;
        StateHasChanged();
    });

            hubConnection.On<char[][], string, int, string>("UpdateState", (newBoard, newCurrentPlayer, remainingTime, newTask) =>
    {
        Console.WriteLine($"Received UpdateState: Board={(newBoard != null ? newBoard.Length : "null")}, CurrentPlayer={newCurrentPlayer}, Time={remainingTime}, Task={newTask}, Username={currentUsername}");

        if (newBoard != null && newBoard.Length > 0 && newBoard.All(row => row != null && row.Length == newBoard.Length))
        {
            // Создаём копию board для защиты от асинхронных изменений
            var boardCopy = new char[newBoard.Length][];
            for (int i = 0; i < newBoard.Length; i++)
            {
                boardCopy[i] = new char[newBoard[i].Length];
                Array.Copy(newBoard[i], boardCopy[i], newBoard[i].Length);
            }
            board = boardCopy;
            boardSize = newBoard.Length;
            Console.WriteLine($"Board validated: Size={boardSize}, Rows={string.Join(", ", Enumerable.Range(0, board.Length).Select(i => $"Row {i}: Length={board[i].Length}"))}");
        }
        else
        {
            Console.WriteLine("UpdateState: Invalid or empty board received");
            errorMessage = "Ошибка: сервер отправил некорректное игровое поле";
        }

        currentPlayer = newCurrentPlayer;
        timerSeconds = remainingTime;
        task = newTask;
        isTaskPhase = !string.IsNullOrEmpty(newTask);
        if (!isTaskPhase)
        {
            selectedRow = -1;
            selectedCol = -1;
        }
        Console.WriteLine($"After UpdateState: boardSize={boardSize}, CurrentPlayer={currentPlayer}, IsTaskPhase={isTaskPhase}, SelectedRow={selectedRow}, SelectedCol={selectedCol}, BoardLength={(board != null ? board.Length : "null")}");
        StartTimer();
        StateHasChanged();
    });

            hubConnection.On<string, int, int, char>("MoveMade", (player, row, col, symbol) =>
            {
                Console.WriteLine($"Received MoveMade: {player}, {row}, {col}, {symbol}, Username={currentUsername}");
                if (board.Length > 0 && row >= 0 && row < board.Length && col >= 0 && col < board[row].Length)
                {
                    board[row][col] = symbol;
                    selectedRow = -1;
                    selectedCol = -1;
                    task = "";
                    isTaskPhase = false;
                    Console.WriteLine($"After MoveMade: IsTaskPhase={isTaskPhase}, SelectedRow={selectedRow}, SelectedCol={selectedCol}");
                    StateHasChanged();
                }
            });

            hubConnection.On<string, string, string, int, int, int, int>("GameOver", (winner, result, lineType, sX, sY, eX, eY) =>
            {
                Console.WriteLine($"Received GameOver: winner={winner}, result={result}, lineType={lineType}, start=({sX},{sY}), end=({eX},{eY})");
                StopTimer();
                StopSessionTimer();
                gameOverMessage = result == "win" ? $"Победил {winner}!" : "Ничья!";
                if (result == "win" && lineType != null && (sX != eX || sY != eY))
                {
                    winLineType = lineType;
                    startX = sX;
                    startY = sY;
                    endX = eX;
                    endY = eY;
                    Console.WriteLine($"Линия установлена: {winLineType}, от ({startX},{startY}) до ({endX},{eY})");
                }
                else
                {
                    winLineType = null;
                    Console.WriteLine("Линия не установлена: либо ничья, либо некорректные координаты.");
                }
                task = "";
                feedback = "";
                selectedRow = -1;
                selectedCol = -1;
                isTaskPhase = false;
                StateHasChanged();
            });

            hubConnection.On<string, char[][], string>("GameReset", (id, newBoard, newCurrentPlayer) =>
            {
                Console.WriteLine($"Received GameReset: {id}");
                if (gameId == id)
                {
                    board = newBoard;
                    currentPlayer = newCurrentPlayer;
                    gameOverMessage = null;
                    winLineType = null;
                    errorMessage = "";
                    task = "";
                    feedback = "";
                    selectedRow = -1;
                    selectedCol = -1;
                    isTaskPhase = false;
                    sessionTimerSeconds = 15 * 60;
                    StartSessionTimer();
                    StartTimer();
                    StateHasChanged();
                }
            });

            hubConnection.On<string>("TaskFeedback", (message) =>
            {
                Console.WriteLine($"Received TaskFeedback: {message}");
                feedback = message;
                StateHasChanged();
                _ = Task.Delay(2000).ContinueWith(_ => { feedback = ""; StateHasChanged(); });
            });

            Console.WriteLine("Starting connection...");
            await hubConnection.StartAsync();
            Console.WriteLine("Connection started");
            connected = true;
            retryCount = 0;
            Console.WriteLine($"Joining game with {currentUsername}, {difficulty}, {lineLength}");
            await hubConnection.SendAsync("JoinGame", currentUsername, difficulty, lineLength);
            Console.WriteLine("Sent JoinGame request");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Connection failed: {ex.Message}");
            if (ex.Message.Contains("401"))
            {
                Console.WriteLine("Connect: 401 error detected, attempting to refresh token");
                await RefreshToken();
                if (!isAuthenticated)
                {
                    Console.WriteLine("Connect: Refresh failed, user not authenticated, redirecting to login");
                    return;
                }

                retryCount++;
                if (retryCount >= maxRetryAttempts)
                {
                    errorMessage = "Превышено количество попыток подключения. Проверьте сервер и попробуйте снова.";
                    Console.WriteLine("Connect: Max retry attempts reached.");
                    await Logout();
                    return;
                }

                Console.WriteLine($"Connect: Retrying connection after token refresh (attempt {retryCount}/{maxRetryAttempts})...");
                if (hubConnection != null)
                {
                    await hubConnection.StopAsync();
                    hubConnection = null;
                }

                hubConnection = new HubConnectionBuilder()
                    .WithUrl("https://26.171.188.146:5001/gameHub", options =>
                    {
                        options.Headers["Authorization"] = $"Bearer {accessToken}";
                    })
                    .WithAutomaticReconnect()
                    .Build();

                try
                {
                    Console.WriteLine("Retrying connection...");
                    await hubConnection.StartAsync();
                    Console.WriteLine("Connection started after retry");
                    connected = true;
                    Console.WriteLine($"Joining game with {currentUsername}, {difficulty}, {lineLength}");
                    await hubConnection.SendAsync("JoinGame", currentUsername, difficulty, lineLength);
                    Console.WriteLine("Sent JoinGame request after retry");
                }
                catch (Exception retryEx)
                {
                    Console.WriteLine($"Retry failed: {retryEx.Message}");
                    errorMessage = $"Не удалось подключиться после {retryCount} попыток: {retryEx.Message}";
                    if (retryCount >= maxRetryAttempts)
                    {
                        await Logout();
                    }
                }
            }
            else if (ex.Message.Contains("500"))
            {
                errorMessage = "Ошибка на сервере при подключении. Проверьте API-сервер.";
                Console.WriteLine("Connect: Server error during connection (500)");
                await Logout();
            }
            else
            {
                errorMessage = $"Ошибка подключения: {ex.Message}. Проверьте, запущен ли сервер.";
                connected = false;
                StateHasChanged();
            }
        }
        finally
        {
            isConnecting = false;
            StateHasChanged();
        }
    }

    private async Task MakeMove(int row, int col)
    {
        if (hubConnection == null || gameId == null || (currentPlayer != currentUsername && !string.IsNullOrEmpty(task))) return;
        try
        {
            Console.WriteLine($"Making move: {row}, {col}, Username={currentUsername}, CurrentPlayer={currentPlayer}, Task={task}");
            selectedRow = row;
            selectedCol = col;
            await hubConnection.SendAsync("MakeMove", gameId, currentUsername, row, col);
            Console.WriteLine("Sent MakeMove request");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"MakeMove failed: {ex.Message}");
            errorMessage = $"Ошибка хода: {ex.Message}";
            if (ex.Message.Contains("401"))
            {
                Console.WriteLine("MakeMove: 401 error detected, refreshing token");
                await RefreshToken();
                if (!isAuthenticated)
                {
                    Console.WriteLine("MakeMove: Refresh failed, redirecting to login");
                    return;
                }
                if (retryCount >= maxRetryAttempts)
                {
                    errorMessage = "Превышено количество попыток выполнения хода. Проверьте сервер и попробуйте снова.";
                    Console.WriteLine("MakeMove: Max retry attempts reached.");
                    await Logout();
                    return;
                }
                retryCount++;
                try
                {
                    Console.WriteLine($"MakeMove: Retrying move after token refresh (attempt {retryCount}/{maxRetryAttempts})...");
                    await hubConnection.SendAsync("MakeMove", gameId, currentUsername, row, col);
                    Console.WriteLine("Sent MakeMove request after retry");
                }
                catch (Exception retryEx)
                {
                    Console.WriteLine($"MakeMove retry failed: {retryEx.Message}");
                    errorMessage = $"Повторный ход не удался: {retryEx.Message}";
                    await Logout();
                }
            }
            else if (ex.Message.Contains("500"))
            {
                errorMessage = "Ошибка на сервере при выполнении хода. Проверьте API-сервер.";
                Console.WriteLine("MakeMove: Server error during move (500)");
                await Logout();
            }
            StateHasChanged();
        }
    }

    private async Task SubmitAnswer()
    {
        if (hubConnection == null || gameId == null || string.IsNullOrEmpty(task) || selectedRow < 0 || selectedCol < 0) return;
        try
        {
            Console.WriteLine($"Submitting answer: {answer}, Username={currentUsername}");
            await hubConnection.SendAsync("SubmitAnswer", gameId, currentUsername, answer);
            answer = "";
            Console.WriteLine("Sent SubmitAnswer request");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"SubmitAnswer failed: {ex.Message}");
            errorMessage = $"Ошибка отправки ответа: {ex.Message}";
            if (ex.Message.Contains("401"))
            {
                Console.WriteLine("SubmitAnswer: 401 error detected, refreshing token");
                await RefreshToken();
                if (!isAuthenticated)
                {
                    Console.WriteLine("SubmitAnswer: Refresh failed, redirecting to login");
                    return;
                }
                if (retryCount >= maxRetryAttempts)
                {
                    errorMessage = "Превышено количество попыток отправки ответа. Проверьте сервер и попробуйте снова.";
                    Console.WriteLine("SubmitAnswer: Max retry attempts reached.");
                    await Logout();
                    return;
                }
                retryCount++;
                try
                {
                    Console.WriteLine($"SubmitAnswer: Retrying submit answer after token refresh (attempt {retryCount}/{maxRetryAttempts})...");
                    await hubConnection.SendAsync("SubmitAnswer", gameId, currentUsername, answer);
                    answer = "";
                    Console.WriteLine("Sent SubmitAnswer request after retry");
                }
                catch (Exception retryEx)
                {
                    Console.WriteLine($"SubmitAnswer retry failed: {retryEx.Message}");
                    errorMessage = $"Повторная отправка ответа не удалась: {retryEx.Message}";
                    await Logout();
                }
            }
            else if (ex.Message.Contains("500"))
            {
                errorMessage = "Ошибка на сервере при отправке ответа. Проверьте API-сервер.";
                Console.WriteLine("SubmitAnswer: Server error during submit (500)");
                await Logout();
            }
            StateHasChanged();
        }
    }

    private async Task ResetGame()
    {
        if (hubConnection == null) return;

        Console.WriteLine("ResetGame called: Starting reset process...");
        try
        {
            StopTimer();
            StopSessionTimer();
            gameOverMessage = null;
            winLineType = null;
            errorMessage = "";
            task = "";
            feedback = "";
            selectedRow = -1;
            selectedCol = -1;
            isTaskPhase = false;
            board = new char[0][];
            sessionTimerSeconds = 15 * 60;

            await hubConnection.StopAsync();
            hubConnection = null;
            connected = false;
            isWaiting = false;
            retryCount = 0;

            await Connect();

            Console.WriteLine("ResetGame completed: Game restarted.");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"ResetGame failed: {ex.Message}");
            errorMessage = $"Ошибка при реванше: {ex.Message}";
            if (ex.Message.Contains("401"))
            {
                Console.WriteLine("ResetGame: 401 error detected, refreshing token");
                await RefreshToken();
            }
            else if (ex.Message.Contains("500"))
            {
                errorMessage = "Ошибка на сервере при реванше. Проверьте API-сервер.";
                Console.WriteLine("ResetGame: Server error during reset (500)");
                await Logout();
            }
            StateHasChanged();
        }
    }

    private async Task ReturnToMainMenu()
    {
        if (hubConnection != null)
        {
            Console.WriteLine("Returning to main menu...");
            StopTimer();
            StopSessionTimer();
            await hubConnection.StopAsync();
            hubConnection = null;
            connected = false;
            isWaiting = false;
            gameId = null;
            playerSymbol = null;
            currentPlayer = null;
            player1 = null;
            player2 = null;
            board = new char[0][];
            gameOverMessage = null;
            winLineType = null;
            errorMessage = "";
            task = "";
            feedback = "";
            selectedRow = -1;
            selectedCol = -1;
            isTaskPhase = false;
            sessionTimerSeconds = 15 * 60;
            retryCount = 0;
            StateHasChanged();
        }
    }

    private void StartTimer()
    {
        StopTimer();
        timer = new Timer(1000);
        timer.Elapsed += (s, e) =>
        {
            timerSeconds--;
            if (timerSeconds <= 0)
            {
                StopTimer();
                if (hubConnection != null && gameId != null && currentPlayer == currentUsername)
                {
                    if (isTaskPhase)
                    {
                        _ = Task.Run(async () => await hubConnection.SendAsync("PassTurn", gameId, currentUsername));
                    }
                    else
                    {
                        _ = Task.Run(async () => await hubConnection.SendAsync("PassTurn", gameId, currentUsername));
                    }
                }
            }
            InvokeAsync(StateHasChanged);
        };
        timerSeconds = isTaskPhase ? 15 : 8;
        timer.Start();
    }

    private void StopTimer()
    {
        timer?.Stop();
        timer?.Dispose();
        timer = null;
        InvokeAsync(StateHasChanged);
    }

    private void StartSessionTimer()
    {
        StopSessionTimer();
        sessionTimer = new Timer(1000);
        sessionTimer.Elapsed += (s, e) =>
        {
            sessionTimerSeconds--;
            if (sessionTimerSeconds <= 0)
            {
                StopSessionTimer();
                if (hubConnection != null && gameId != null)
                {
                    _ = Task.Run(async () => await hubConnection.SendAsync("PassTurn", gameId, currentUsername));
                }
            }
            InvokeAsync(StateHasChanged);
        };
        sessionTimer.Start();
    }

    private void StopSessionTimer()
    {
        sessionTimer?.Stop();
        sessionTimer?.Dispose();
        sessionTimer = null;
        InvokeAsync(StateHasChanged);
    }

    private char[][] CreateEmptyBoard(int size)
    {
        var newBoard = new char[size][];
        for (int i = 0; i < size; i++)
        {
            newBoard[i] = new char[size];
        }
        return newBoard;
    }

    public async ValueTask DisposeAsync()
    {
        StopTimer();
        StopSessionTimer();
        if (hubConnection is not null)
        {
            Console.WriteLine("Disposing connection...");
            await hubConnection.DisposeAsync();
        }
    }

    public class RefreshTokenRequest
    {
        public string AccessToken { get; set; }
        public string RefreshToken { get; set; }
    }

    public class RefreshTokenResponse
    {
        public string AccessToken { get; set; }
        public string RefreshToken { get; set; }
    }

    public class ValidateTokenResponse
    {
        public int UserId { get; set; }
        public string Username { get; set; }
    }
}